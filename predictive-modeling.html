<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Data Science for Startups</title>
  <meta name="description" content="Data Science for Startups">
  <meta name="generator" content="bookdown 0.7.8 and GitBook 2.6.7">

  <meta property="og:title" content="Data Science for Startups" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="Data Science for Startups" />
  <meta name="github-repo" content="bgweber/StartupDataScience" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Data Science for Startups" />
  
  <meta name="twitter:description" content="Data Science for Startups" />
  

<meta name="author" content="Ben G Weber">


<meta name="date" content="2018-05-29">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="exploratory-data-analysis.html">
<link rel="next" href="productizing-models.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Data Science for Startups</a></li>

<li class="divider"></li>
<li class="chapter" data-level="1" data-path="intro.html"><a href="intro.html"><i class="fa fa-check"></i><b>1</b> Introduction</a><ul>
<li class="chapter" data-level="1.1" data-path="intro.html"><a href="intro.html#why-data-science"><i class="fa fa-check"></i><b>1.1</b> Why Data Science?</a></li>
<li class="chapter" data-level="1.2" data-path="intro.html"><a href="intro.html#book-overview"><i class="fa fa-check"></i><b>1.2</b> Book Overview</a></li>
<li class="chapter" data-level="1.3" data-path="intro.html"><a href="intro.html#tooling"><i class="fa fa-check"></i><b>1.3</b> Tooling</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="tracking-data.html"><a href="tracking-data.html"><i class="fa fa-check"></i><b>2</b> Tracking Data</a><ul>
<li class="chapter" data-level="2.1" data-path="tracking-data.html"><a href="tracking-data.html#what-to-record"><i class="fa fa-check"></i><b>2.1</b> What to Record?</a></li>
<li class="chapter" data-level="2.2" data-path="tracking-data.html"><a href="tracking-data.html#tracking-specs"><i class="fa fa-check"></i><b>2.2</b> Tracking Specs</a></li>
<li class="chapter" data-level="2.3" data-path="tracking-data.html"><a href="tracking-data.html#client-vs-server-tracking"><i class="fa fa-check"></i><b>2.3</b> Client vs Server Tracking</a></li>
<li class="chapter" data-level="2.4" data-path="tracking-data.html"><a href="tracking-data.html#sending-tracking-events"><i class="fa fa-check"></i><b>2.4</b> Sending Tracking Events</a><ul>
<li class="chapter" data-level="2.4.1" data-path="tracking-data.html"><a href="tracking-data.html#web-call"><i class="fa fa-check"></i><b>2.4.1</b> Web Call</a></li>
<li class="chapter" data-level="2.4.2" data-path="tracking-data.html"><a href="tracking-data.html#web-server"><i class="fa fa-check"></i><b>2.4.2</b> Web Server</a></li>
<li class="chapter" data-level="2.4.3" data-path="tracking-data.html"><a href="tracking-data.html#subscription-service"><i class="fa fa-check"></i><b>2.4.3</b> Subscription Service</a></li>
</ul></li>
<li class="chapter" data-level="2.5" data-path="tracking-data.html"><a href="tracking-data.html#message-encoding"><i class="fa fa-check"></i><b>2.5</b> Message Encoding</a></li>
<li class="chapter" data-level="2.6" data-path="tracking-data.html"><a href="tracking-data.html#building-a-tracking-api"><i class="fa fa-check"></i><b>2.6</b> Building a Tracking API</a></li>
<li class="chapter" data-level="2.7" data-path="tracking-data.html"><a href="tracking-data.html#privacy"><i class="fa fa-check"></i><b>2.7</b> Privacy</a></li>
<li class="chapter" data-level="2.8" data-path="tracking-data.html"><a href="tracking-data.html#conclusion"><i class="fa fa-check"></i><b>2.8</b> Conclusion</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="data-pipelines.html"><a href="data-pipelines.html"><i class="fa fa-check"></i><b>3</b> Data Pipelines</a><ul>
<li class="chapter" data-level="3.1" data-path="data-pipelines.html"><a href="data-pipelines.html#types-of-data"><i class="fa fa-check"></i><b>3.1</b> Types of Data</a></li>
<li class="chapter" data-level="3.2" data-path="data-pipelines.html"><a href="data-pipelines.html#the-evolution-of-data-pipelines"><i class="fa fa-check"></i><b>3.2</b> The Evolution of Data Pipelines</a><ul>
<li class="chapter" data-level="3.2.1" data-path="data-pipelines.html"><a href="data-pipelines.html#flat-file-era"><i class="fa fa-check"></i><b>3.2.1</b> Flat File Era</a></li>
<li class="chapter" data-level="3.2.2" data-path="data-pipelines.html"><a href="data-pipelines.html#database-era"><i class="fa fa-check"></i><b>3.2.2</b> Database Era</a></li>
<li class="chapter" data-level="3.2.3" data-path="data-pipelines.html"><a href="data-pipelines.html#data-lake-era"><i class="fa fa-check"></i><b>3.2.3</b> Data Lake Era</a></li>
<li class="chapter" data-level="3.2.4" data-path="data-pipelines.html"><a href="data-pipelines.html#serverless-era"><i class="fa fa-check"></i><b>3.2.4</b> Serverless Era</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="data-pipelines.html"><a href="data-pipelines.html#a-scalable-pipeline"><i class="fa fa-check"></i><b>3.3</b> A Scalable Pipeline</a><ul>
<li class="chapter" data-level="3.3.1" data-path="data-pipelines.html"><a href="data-pipelines.html#setting-up-the-environment"><i class="fa fa-check"></i><b>3.3.1</b> Setting up the Environment</a></li>
<li class="chapter" data-level="3.3.2" data-path="data-pipelines.html"><a href="data-pipelines.html#publishing-events"><i class="fa fa-check"></i><b>3.3.2</b> Publishing Events</a></li>
<li class="chapter" data-level="3.3.3" data-path="data-pipelines.html"><a href="data-pipelines.html#storing-events"><i class="fa fa-check"></i><b>3.3.3</b> Storing Events</a></li>
<li class="chapter" data-level="3.3.4" data-path="data-pipelines.html"><a href="data-pipelines.html#deploying-and-auto-scaling"><i class="fa fa-check"></i><b>3.3.4</b> Deploying and Auto Scaling</a></li>
<li class="chapter" data-level="3.3.5" data-path="data-pipelines.html"><a href="data-pipelines.html#raw-to-processed-events"><i class="fa fa-check"></i><b>3.3.5</b> Raw to Processed Events</a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="data-pipelines.html"><a href="data-pipelines.html#conclusion-1"><i class="fa fa-check"></i><b>3.4</b> Conclusion</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="business-intelligence.html"><a href="business-intelligence.html"><i class="fa fa-check"></i><b>4</b> Business Intelligence</a><ul>
<li class="chapter" data-level="4.1" data-path="business-intelligence.html"><a href="business-intelligence.html#kpis"><i class="fa fa-check"></i><b>4.1</b> KPIs</a></li>
<li class="chapter" data-level="4.2" data-path="business-intelligence.html"><a href="business-intelligence.html#reporting-with-r"><i class="fa fa-check"></i><b>4.2</b> Reporting with R</a><ul>
<li class="chapter" data-level="4.2.1" data-path="business-intelligence.html"><a href="business-intelligence.html#base-r"><i class="fa fa-check"></i><b>4.2.1</b> Base R</a></li>
<li class="chapter" data-level="4.2.2" data-path="business-intelligence.html"><a href="business-intelligence.html#r-markdown"><i class="fa fa-check"></i><b>4.2.2</b> R Markdown</a></li>
<li class="chapter" data-level="4.2.3" data-path="business-intelligence.html"><a href="business-intelligence.html#r-shiny"><i class="fa fa-check"></i><b>4.2.3</b> R Shiny</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="business-intelligence.html"><a href="business-intelligence.html#etls"><i class="fa fa-check"></i><b>4.3</b> ETLs</a></li>
<li class="chapter" data-level="4.4" data-path="business-intelligence.html"><a href="business-intelligence.html#reporting-tools"><i class="fa fa-check"></i><b>4.4</b> Reporting Tools</a><ul>
<li class="chapter" data-level="4.4.1" data-path="business-intelligence.html"><a href="business-intelligence.html#google-data-studio"><i class="fa fa-check"></i><b>4.4.1</b> Google Data Studio</a></li>
<li class="chapter" data-level="4.4.2" data-path="business-intelligence.html"><a href="business-intelligence.html#tableau"><i class="fa fa-check"></i><b>4.4.2</b> Tableau</a></li>
<li class="chapter" data-level="4.4.3" data-path="business-intelligence.html"><a href="business-intelligence.html#mode"><i class="fa fa-check"></i><b>4.4.3</b> Mode</a></li>
<li class="chapter" data-level="4.4.4" data-path="business-intelligence.html"><a href="business-intelligence.html#custom-tooling"><i class="fa fa-check"></i><b>4.4.4</b> Custom Tooling</a></li>
</ul></li>
<li class="chapter" data-level="4.5" data-path="business-intelligence.html"><a href="business-intelligence.html#conclusion-2"><i class="fa fa-check"></i><b>4.5</b> Conclusion</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="exploratory-data-analysis.html"><a href="exploratory-data-analysis.html"><i class="fa fa-check"></i><b>5</b> Exploratory Data Analysis</a><ul>
<li class="chapter" data-level="5.1" data-path="exploratory-data-analysis.html"><a href="exploratory-data-analysis.html#summary-statistics"><i class="fa fa-check"></i><b>5.1</b> Summary Statistics</a></li>
<li class="chapter" data-level="5.2" data-path="exploratory-data-analysis.html"><a href="exploratory-data-analysis.html#plotting"><i class="fa fa-check"></i><b>5.2</b> Plotting</a></li>
<li class="chapter" data-level="5.3" data-path="exploratory-data-analysis.html"><a href="exploratory-data-analysis.html#correlation-analysis"><i class="fa fa-check"></i><b>5.3</b> Correlation Analysis</a></li>
<li class="chapter" data-level="5.4" data-path="exploratory-data-analysis.html"><a href="exploratory-data-analysis.html#feature-importance"><i class="fa fa-check"></i><b>5.4</b> Feature Importance</a></li>
<li class="chapter" data-level="5.5" data-path="exploratory-data-analysis.html"><a href="exploratory-data-analysis.html#conclusion-3"><i class="fa fa-check"></i><b>5.5</b> Conclusion</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="predictive-modeling.html"><a href="predictive-modeling.html"><i class="fa fa-check"></i><b>6</b> Predictive Modeling</a><ul>
<li class="chapter" data-level="6.1" data-path="predictive-modeling.html"><a href="predictive-modeling.html#types-of-predictive-models"><i class="fa fa-check"></i><b>6.1</b> Types of Predictive Models</a></li>
<li class="chapter" data-level="6.2" data-path="predictive-modeling.html"><a href="predictive-modeling.html#training-a-classification-model"><i class="fa fa-check"></i><b>6.2</b> Training a Classification Model</a><ul>
<li class="chapter" data-level="6.2.1" data-path="predictive-modeling.html"><a href="predictive-modeling.html#weka"><i class="fa fa-check"></i><b>6.2.1</b> Weka</a></li>
<li class="chapter" data-level="6.2.2" data-path="predictive-modeling.html"><a href="predictive-modeling.html#bigml"><i class="fa fa-check"></i><b>6.2.2</b> BigML</a></li>
<li class="chapter" data-level="6.2.3" data-path="predictive-modeling.html"><a href="predictive-modeling.html#r-glmnet"><i class="fa fa-check"></i><b>6.2.3</b> R — Glmnet</a></li>
<li class="chapter" data-level="6.2.4" data-path="predictive-modeling.html"><a href="predictive-modeling.html#python-scikit-learn"><i class="fa fa-check"></i><b>6.2.4</b> Python — scikit-learn</a></li>
</ul></li>
<li class="chapter" data-level="6.3" data-path="predictive-modeling.html"><a href="predictive-modeling.html#clustering"><i class="fa fa-check"></i><b>6.3</b> Clustering</a><ul>
<li class="chapter" data-level="6.3.1" data-path="predictive-modeling.html"><a href="predictive-modeling.html#how-many-clusters-to-use"><i class="fa fa-check"></i><b>6.3.1</b> How many clusters to use?</a></li>
<li class="chapter" data-level="6.3.2" data-path="predictive-modeling.html"><a href="predictive-modeling.html#cluster-descriptions"><i class="fa fa-check"></i><b>6.3.2</b> Cluster Descriptions</a></li>
<li class="chapter" data-level="6.3.3" data-path="predictive-modeling.html"><a href="predictive-modeling.html#cluster-populations-by-net-worth"><i class="fa fa-check"></i><b>6.3.3</b> Cluster Populations by Net Worth</a></li>
</ul></li>
<li class="chapter" data-level="6.4" data-path="predictive-modeling.html"><a href="predictive-modeling.html#conclusion-4"><i class="fa fa-check"></i><b>6.4</b> Conclusion</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="productizing-models.html"><a href="productizing-models.html"><i class="fa fa-check"></i><b>7</b> Productizing Models</a><ul>
<li class="chapter" data-level="7.1" data-path="productizing-models.html"><a href="productizing-models.html#building-a-model-specification"><i class="fa fa-check"></i><b>7.1</b> Building a Model Specification</a></li>
<li class="chapter" data-level="7.2" data-path="productizing-models.html"><a href="productizing-models.html#batch-deployments"><i class="fa fa-check"></i><b>7.2</b> Batch Deployments</a><ul>
<li class="chapter" data-level="7.2.1" data-path="productizing-models.html"><a href="productizing-models.html#sql-query"><i class="fa fa-check"></i><b>7.2.1</b> SQL Query</a></li>
<li class="chapter" data-level="7.2.2" data-path="productizing-models.html"><a href="productizing-models.html#dataflow-bigquery"><i class="fa fa-check"></i><b>7.2.2</b> DataFlow — BigQuery</a></li>
<li class="chapter" data-level="7.2.3" data-path="productizing-models.html"><a href="productizing-models.html#dataflow-datastore"><i class="fa fa-check"></i><b>7.2.3</b> DataFlow — DataStore</a></li>
</ul></li>
<li class="chapter" data-level="7.3" data-path="productizing-models.html"><a href="productizing-models.html#live-deployments"><i class="fa fa-check"></i><b>7.3</b> Live Deployments</a><ul>
<li class="chapter" data-level="7.3.1" data-path="productizing-models.html"><a href="productizing-models.html#web-service"><i class="fa fa-check"></i><b>7.3.1</b> Web Service</a></li>
<li class="chapter" data-level="7.3.2" data-path="productizing-models.html"><a href="productizing-models.html#dataflow---pubsub"><i class="fa fa-check"></i><b>7.3.2</b> DataFlow - PubSub</a></li>
<li class="chapter" data-level="7.3.3" data-path="productizing-models.html"><a href="productizing-models.html#custom-engineering"><i class="fa fa-check"></i><b>7.3.3</b> Custom Engineering</a></li>
</ul></li>
<li class="chapter" data-level="7.4" data-path="productizing-models.html"><a href="productizing-models.html#conclusion-5"><i class="fa fa-check"></i><b>7.4</b> Conclusion</a></li>
</ul></li>
<li class="chapter" data-level="8" data-path="experimentation.html"><a href="experimentation.html"><i class="fa fa-check"></i><b>8</b> Experimentation</a><ul>
<li class="chapter" data-level="8.1" data-path="experimentation.html"><a href="experimentation.html#staged-rollouts"><i class="fa fa-check"></i><b>8.1</b> Staged Rollouts</a><ul>
<li class="chapter" data-level="8.1.1" data-path="experimentation.html"><a href="experimentation.html#staged-rollout-biases"><i class="fa fa-check"></i><b>8.1.1</b> Staged Rollout Biases</a></li>
<li class="chapter" data-level="8.1.2" data-path="experimentation.html"><a href="experimentation.html#time-series-analysis"><i class="fa fa-check"></i><b>8.1.2</b> Time Series Analysis</a></li>
<li class="chapter" data-level="8.1.3" data-path="experimentation.html"><a href="experimentation.html#difference-in-differences-estimation"><i class="fa fa-check"></i><b>8.1.3</b> Difference-in-Differences Estimation</a></li>
</ul></li>
<li class="chapter" data-level="8.2" data-path="experimentation.html"><a href="experimentation.html#conclusion-6"><i class="fa fa-check"></i><b>8.2</b> Conclusion</a></li>
</ul></li>
<li class="chapter" data-level="9" data-path="recommendation-systems.html"><a href="recommendation-systems.html"><i class="fa fa-check"></i><b>9</b> Recommendation Systems</a><ul>
<li class="chapter" data-level="9.1" data-path="recommendation-systems.html"><a href="recommendation-systems.html#r---recommender-lab"><i class="fa fa-check"></i><b>9.1</b> R - Recommender Lab</a></li>
<li class="chapter" data-level="9.2" data-path="recommendation-systems.html"><a href="recommendation-systems.html#java---apache-mahout"><i class="fa fa-check"></i><b>9.2</b> Java - Apache Mahout</a></li>
<li class="chapter" data-level="9.3" data-path="recommendation-systems.html"><a href="recommendation-systems.html#scala---mllib"><i class="fa fa-check"></i><b>9.3</b> Scala - MLlib</a></li>
<li class="chapter" data-level="9.4" data-path="recommendation-systems.html"><a href="recommendation-systems.html#sql---spark-sql"><i class="fa fa-check"></i><b>9.4</b> SQL - Spark SQL</a></li>
<li class="chapter" data-level="9.5" data-path="recommendation-systems.html"><a href="recommendation-systems.html#conclusion-7"><i class="fa fa-check"></i><b>9.5</b> Conclusion</a></li>
</ul></li>
<li class="chapter" data-level="10" data-path="deep-learning.html"><a href="deep-learning.html"><i class="fa fa-check"></i><b>10</b> Deep Learning</a><ul>
<li class="chapter" data-level="10.1" data-path="deep-learning.html"><a href="deep-learning.html#improving-shallow-problems"><i class="fa fa-check"></i><b>10.1</b> Improving Shallow Problems</a></li>
<li class="chapter" data-level="10.2" data-path="deep-learning.html"><a href="deep-learning.html#loss-functions-in-keras"><i class="fa fa-check"></i><b>10.2</b> Loss Functions in Keras</a></li>
<li class="chapter" data-level="10.3" data-path="deep-learning.html"><a href="deep-learning.html#evaluating-loss-functions"><i class="fa fa-check"></i><b>10.3</b> Evaluating Loss Functions</a></li>
<li class="chapter" data-level="10.4" data-path="deep-learning.html"><a href="deep-learning.html#conclusion-8"><i class="fa fa-check"></i><b>10.4</b> Conclusion</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i>References</a></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Data Science for Startups</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="predictive-modeling" class="section level1">
<h1><span class="header-section-number">Chapter 6</span> Predictive Modeling</h1>
<p>Machine learning can be used to make predictions about the future. You provide a model with a collection of training instances, fit the model on this data set, and then apply the model to new instances to make predictions. Predictive modeling is useful for startups, because you can make products that adapt based on expected user behavior. For example, if a viewer consistently watches the same broadcaster on a streaming service, the application can load that channel on application startup. Predictive models can also be used to build data products, such as a recommendation system that could recommend new broadcasters to the viewer.</p>
<p>This chapter provides a light introduction to predictive modeling with machine learning. I’ll discuss the different types of prediction problems and introduce some of the commonly used approaches, present approaches for building models using open tools and scripting languages, and provide an applied example of clustering. The goal for this chapter isn’t to provide an in-depth understanding of specific methods, but to show how a variety of tools can be used to quickly prototype different types of models.</p>
<div id="types-of-predictive-models" class="section level2">
<h2><span class="header-section-number">6.1</span> Types of Predictive Models</h2>
<p>Machine learning models typically fail into two categories: supervised learning and unsupervised learning. For supervised problems, the data being used to fit a model has specified labels, or target variables. For example, if the goal is to identify which users in a mobile game are likely to become purchasers, we can use transaction data from past users as labels, where 1 means a paid user and 0 means a free user. The label is used as input to the supervised algorithm to provide feedback when fitting the model to a training data set. Classification and regression algorithms are two types of supervised learning. In a classification task, the goal is to predict the likelihood of an outcome, such as whether or not a mobile game user will make a purchase. For regression, the goal is to predict a continuous variable, such as the price of a home given a description of different features.</p>
<p>For unsupervised problems, no explicit labels are provided for training a model. The most common type of unsupervised learning method is clustering, which infers labels by forming groups of different instances in a data set. Clustering is useful for answering segmentation questions, such as what are the different archetypes of users that a product should support.</p>
<p>There are two other types of machine learning models that I won’t cover here: semi-supervised learning and reinforcement learning. Semi-supervised learning is a process that identifies target labels as part of the training process, and is often implemented with autoencoders in deep learning. Reinforcement learning is a model that is updated based on a reward policy, where the actions taken by a model provide positive and negative feedback signals and are used to update the model.</p>
<p>For a startup, you’re likely going to get started with classification and regression models, which are often referred to as classic, or shallow machine learning problems. There’s a wide variety of different approaches that can be used. Some common approaches for classification are logistic regression, naive bayes, decision trees, and ensemble methods such as random forests and XGBoost. Common approaches for regression include many of the same approaches as classification, but linear regression is used in place of logistic regression. Support vector machines were popular back when I was in grad school a decade ago, but now XGBoost seems to be the king of shallow learning problems.</p>
<p>It’s important to know how different algorithms are implemented, because if you want to ship a predictive model as part of a product, it needs to be reliable and scalable. Generally, eager models are preferred over lazy models when shipping products. Eager models are approaches that generate a ruleset as part of the training process, such as the coefficients in a linear regression model, while a lazy model generates the rule set at run time. For example, a nearest neighbor (k-NN) model is a lazy approach. Lazy methods are often useful for building online learning systems, where the model is frequently updated with new data while deployed, but may have scalability issues.</p>
<p>How the performance of a predictive model is evaluated depends on the type of problem being performed. For example, metrics such as mean absolute error (MAE), root-mean squared error (RMSE), and correlation coefficients are useful for evaluating regression models, while ROC area under the curve (AUC), precision, recall, and lift are useful for classification problems.</p>
</div>
<div id="training-a-classification-model" class="section level2">
<h2><span class="header-section-number">6.2</span> Training a Classification Model</h2>
<p>This section presents a few different approaches that can be used to build a classification model. We’ll use the same data set as the past chapter on EDA, but instead of predicting birth weights in the Natality data set, we’ll attempt to predict which pregnancies will result in twins instead of singletons.</p>
<p>To start, we’ll need to pull a data set locally that we can use as input to different tools. The R code below shows how to sample 100k pregnancies and save the data frame to a CSV. This query is similar to the one from the past chapter, but I’ve included additional constraints in the where clause to avoid pulling records with missing (NA) values.</p>
<p> </p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(bigrquery)
project &lt;-<span class="st"> &quot;your_project_id&quot;</span>
<span class="kw">options</span>(<span class="dt">stringsAsFactors =</span> <span class="ot">FALSE</span>)

sql &lt;-<span class="st"> &quot;SELECT year, mother_age</span>
<span class="st"> ,father_age, gestation_weeks</span>
<span class="st"> ,case when ever_born &gt; 0 then ever_born </span>
<span class="st">     else 0 end as ever_born</span>
<span class="st"> ,case when mother_married then 1 </span>
<span class="st">     else 0 end as mother_married</span>
<span class="st"> ,weight_pounds</span>
<span class="st"> ,case when plurality = 2 then 1 else 0 end as label</span>
<span class="st">FROM `bigquery-public-data.samples.natality`</span>
<span class="st">where plurality in (1, 2) </span>
<span class="st">  and gestation_weeks between 1 and 90</span>
<span class="st">  and weight_pounds between 1 and 20</span>
<span class="st">order by rand() </span>
<span class="st">LIMIT 100000&quot;</span>

df &lt;-<span class="st"> </span><span class="kw">query_exec</span>(sql, <span class="dt">project =</span> project, 
                 <span class="dt">use_legacy_sql =</span> <span class="ot">FALSE</span>)
<span class="kw">write.csv</span>(df, <span class="st">&quot;natality.csv&quot;</span>, <span class="dt">row.names =</span> <span class="ot">FALSE</span>)</code></pre></div>
<p>One of the challenges with this data set is that there are way more negative examples in this data set than there are positive examples. Only 2.4% of the pregnancies in the sampled data set have a label of ‘1’, indicating twins. This means we’ll need to use metrics other than accuracy in order to gauge the performance of different approaches. Accuracy is not a good metric for problems with a large class imbalance such as this one, because predicting a label of 0 for every record results in an accuracy of 97.6%. Instead, we’ll use the AUC curve metric for evaluating different models, since it’s useful for handling problems with imbalanced classes.</p>
<p>Another consideration when evaluating different models is using different training, test, and holdout data sets. The holdout data set is withheld until the end of the model training process, and used only once for evaluation. Training and test data sets can be used as frequently as necessary when building and tuning a model. Methods such as 10-fold cross validation are useful for building robust estimates of model performance. This is typically the approach I take when building models, but for the sake of brevity is not covered in all of the different examples below.</p>
<div id="weka" class="section level3">
<h3><span class="header-section-number">6.2.1</span> Weka</h3>
<p>One of the tools that I like to use for exploratory analysis and evaluating different modeling algorithms is Weka<a href="#fn14" class="footnoteRef" id="fnref14"><sup>14</sup></a>, which is implemented in Java and provides a GUI for exploring different models. It’s a bit dated now, but I still find it quite useful for quickly digging into a data set and determining if there’s much of a signal available for predicting an outcome.</p>
<div class="figure"><span id="fig:6-1"></span>
<img src="images/6-1.png" alt="Visualizing different features in the data set with Weka." width="100%" />
<p class="caption">
Figure 6.1: Visualizing different features in the data set with Weka.
</p>
</div>
<p>The chart above shows visualizations of different features in the data set. The red data points represent the positive examples (twins), and the blue data points represent negative examples (singletons). For features with a strong signal, it’s often possible to draw a vertical line that separates most of the red and blue data points. This isn’t the case with this data set, and we’ll need to combine different features to build a good classifier.</p>
<p>I used Weka to explore the following algorithms and to compute AUC metrics when using 10-fold cross validation:</p>
<ul>
<li><strong>Logistic:</strong> 0.892</li>
<li><strong>LogitBoost:</strong> 0.908</li>
</ul>
<p>The best performing algorithm out of the ones I explored was LogitBoost. This algorithm has a number of hyperparameters, such as number of iterations, that be be tuned to further improve the performance of the model. There may be other algorithms in Weka that work even better on this data set, but our initial exploration has resulted in promising results.</p>
<div class="figure"><span id="fig:6-2"></span>
<img src="images/6-2.png" alt="Visualizing the ROC Curve with Weka." width="100%" />
<p class="caption">
Figure 6.2: Visualizing the ROC Curve with Weka.
</p>
</div>
<p>A visualization of the ROC curve for the logistic regression model is shown in the figure below. It’s also possible to explore the importance of different features in a logistic regression model with Weka. You can inspect the coefficients of the model directly. For example, weight_pounds has the highest coefficient value of 0.93. It’s also possible to use the InfoGain attribute ranker to determine which features are most important for this classification task. Weka found that weight_pounds (0.0415) was the most influential feature, followed by gestation_weeks (0.0243).</p>
<p>Weka is usually not the best choice for productizing models, but it does provide a useful tool for exploring a wide variety of different algorithms.</p>
</div>
<div id="bigml" class="section level3">
<h3><span class="header-section-number">6.2.2</span> BigML</h3>
<p>Another tool that I’ve used in my startup experience is BigML<a href="#fn15" class="footnoteRef" id="fnref15"><sup>15</sup></a>. This tool is similar to Weka in that it provides a GUI (web-based) for exploring different types of models without requiring any coding. The tool has fewer options than Weka, but has more recent models such as DeepNets.</p>
<div class="figure"><span id="fig:6-3"></span>
<img src="images/6-3.png" alt="Evaluating Feature Importance in a Logistic Model with BigML." width="100%" />
<p class="caption">
Figure 6.3: Evaluating Feature Importance in a Logistic Model with BigML.
</p>
</div>
<p>The image below shows one of the feature importance tools provided by BigML. These tools are useful for understanding which features are useful in predicting an outcome. I explored two different models with BigML, resulting in the following AUC metrics:</p>
<ul>
<li><strong>Logistic:</strong> 0.890</li>
<li><strong>DeepNet:</strong> 0.902</li>
</ul>
<p>Instead of using 10-fold cross validation, I used a single 80/20 split of the data to evaluate the different models. The performance of the models in BigML was similar to Weka, but did not quite match the performance of LogitBoost.</p>
<div class="figure"><span id="fig:6-4"></span>
<img src="images/6-4.png" alt="Evaluation Metrics provided by BigML." width="100%" />
<p class="caption">
Figure 6.4: Evaluation Metrics provided by BigML.
</p>
</div>
<p>In addition to plotting ROC curves, as shown below, BigML can plot other useful visualizations such as lift charts. BigML also provides useful classification metrics such as precision, recall, and F1 score.</p>
</div>
<div id="r-glmnet" class="section level3">
<h3><span class="header-section-number">6.2.3</span> R — Glmnet</h3>
<p>We can implement the logistic regression model that we’ve already evaluated using the glm library in R. The generalized linear models function can be applied to logistic regression by specifying the binomial family as input. R code that loads the CSV and trains a logistic regression model is shown below.</p>
<p> </p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">&quot;Natality.csv&quot;</span>)
fit &lt;-<span class="st"> </span><span class="kw">glm</span>(label <span class="op">~</span><span class="st"> </span>.,<span class="dt">family=</span><span class="kw">binomial</span>(), <span class="dt">data=</span>df)
fit

<span class="kw">library</span>(Deducer)
<span class="kw">rocplot</span>(fit)</code></pre></div>
<p>After fitting the model, the fit statement outputs the coefficients of the model. To evaluate the performance of the model, I used the Deducer library, which includes an rocplot function. For this basic model fitting approach, I did not perform any cross validation. The result was an AUC of 0.890 on the training data set.</p>
<div class="figure"><span id="fig:6-5"></span>
<img src="images/6-5.png" alt="ROC Curve for the logistic regression model in R." width="100%" />
<p class="caption">
Figure 6.5: ROC Curve for the logistic regression model in R.
</p>
</div>
<p>To use regularization when fitting a logistic regression model in R, we can use the glmnet library, which provides lasso and ridge regression. An example of using this package to evaluate feature importance is shown in the code below:</p>
<p> </p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(glmnet)
x &lt;-<span class="st"> </span><span class="kw">sparse.model.matrix</span>(label <span class="op">~</span><span class="st"> </span>., <span class="dt">data =</span> df)
y &lt;-<span class="st"> </span><span class="kw">as.factor</span>(df<span class="op">$</span>label)

fit =<span class="st"> </span><span class="kw">glmnet</span>(x, y, <span class="dt">family =</span> <span class="st">&quot;binomial&quot;</span>)
<span class="kw">plot</span>(fit, <span class="dt">xvar =</span> <span class="st">&quot;dev&quot;</span>, <span class="dt">label =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p>By default, the “least squares” model is used to fit the training data. The chart below shows how the coefficients of the model vary as additional factors are used as input to the model. Initially, only the weight_pounds features is used as input. Once this term begins getting penalized, around the value of -0.6, additional features are considered for the model.</p>
<div class="figure"><span id="fig:6-6"></span>
<img src="images/6-6.png" alt="Feature weights based on different lambda values for glmnet." width="100%" />
<p class="caption">
Figure 6.6: Feature weights based on different lambda values for glmnet.
</p>
</div>
<p> </p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">cvfit =<span class="st"> </span><span class="kw">cv.glmnet</span>(x, y, <span class="dt">family =</span> <span class="st">&quot;binomial&quot;</span>, 
                  <span class="dt">type.measure =</span> <span class="st">&quot;auc&quot;</span>)
<span class="kw">cat</span>(<span class="kw">paste</span>(<span class="st">&quot;ROC:&quot;</span>, <span class="kw">max</span>(cvfit<span class="op">$</span>cvlo)))
<span class="kw">plot</span>(cvfit)</code></pre></div>
<p>The glmnet package provides a built-in cross validation feature that can be used to optimize for different metrics, such AUC. The R code above shows how to train a logistic regression model using this feature, and plots the outcome in the figure shown above. The AUC metric for the regularized logistic regression model was 0.893.</p>
<div class="figure"><span id="fig:6-7"></span>
<img src="images/6-7.png" alt="Performance (AUC) of the glmnet model based on different lambda values." width="100%" />
<p class="caption">
Figure 6.7: Performance (AUC) of the glmnet model based on different lambda values.
</p>
</div>
</div>
<div id="python-scikit-learn" class="section level3">
<h3><span class="header-section-number">6.2.4</span> Python — scikit-learn</h3>
<p>Another tool that I wanted to cover in this section is scikit-learn, because it provides a standardized way of exploring the accuracy of different types of models. I’ve been focused on R for model fitting and EDA so far, but the Python tooling available through scikit-learn is pretty useful.</p>
<p> </p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># load the data set</span>
import pandas as pd
df =<span class="st"> </span><span class="kw">pd.read_csv</span>(<span class="st">&#39;./Natality.csv&#39;</span>)

<span class="co"># build a random forest classifier </span>
from sklearn.ensemble import RandomForestClassifier
rf =<span class="st"> </span><span class="kw">RandomForestClassifier</span>()
x =<span class="st"> </span><span class="kw">df.drop</span>(<span class="st">&#39;label&#39;</span>, <span class="dt">axis=</span><span class="dv">1</span>)
y =<span class="st"> </span>df[<span class="st">&#39;label&#39;</span>]
<span class="kw">rf.fit</span>(x, y)

<span class="co"># evaluate the results </span>
from sklearn.metrics import roc_curve, auc
false_positive_rate, true_positive_rate, _ =<span class="st"> </span>
<span class="st">  </span><span class="kw">roc_curve</span>(y, <span class="kw">rf.predict</span>(x))
roc_auc =<span class="st"> </span><span class="kw">auc</span>(false_positive_rate, true_positive_rate)

<span class="co"># plot the curve</span>
import matplotlib.pyplot as plt
<span class="kw">plt.plot</span>(false_positive_rate, true_positive_rate, 
    <span class="st">&#39;b&#39;</span>, <span class="dt">label=</span><span class="st">&#39;AUC = %0.2f&#39;</span>% roc_auc)
<span class="kw">plt.legend</span>(<span class="dt">loc=</span><span class="st">&#39;lower right&#39;</span>)
<span class="kw">plt.show</span>()</code></pre></div>
<p>The Python code above shows how to read in a data frame using pandas, fit a random forest model using sklearn, evaluate the performance of the model, and plot the results, as shown in the figure below.</p>
<div class="figure" style="text-align: center"><span id="fig:6-8"></span>
<img src="images/6-8.png" alt="ROC Curve for the RF model in scikit-learn." width="70%" />
<p class="caption">
Figure 6.8: ROC Curve for the RF model in scikit-learn.
</p>
</div>
</div>
</div>
<div id="clustering" class="section level2">
<h2><span class="header-section-number">6.3</span> Clustering</h2>
<p>One of the types of analysis that is useful for startups is understanding if there’s different segments, or clusters of users. The general approach to this type of work is to first identify clusters in the data, assign labels to these clusters, and then assign labels to new records based on the labeled clusters. This section shows how to perform this type of process using data from the 2016 Federal Reserve Survey of Consumer Finances<a href="#fn16" class="footnoteRef" id="fnref16"><sup>16</sup></a>.</p>
<p>The survey data set provides a breakdown of assets for thousands of households in the US. The goal of this clustering exercise is to identify if there are different types of affluent households, with a net worth of $1M+ USD. The complete code to load the data and perform the analysis is provided in the Jupyter notebook online<a href="#fn17" class="footnoteRef" id="fnref17"><sup>17</sup></a>. Prior analysis with this data set is available online<a href="#fn18" class="footnoteRef" id="fnref18"><sup>18</sup></a>.</p>
<p>For each of the surveyed households, we have a number of columns that specify how assets are allocated for the household, including residential and commercial real estate, business equity, retirement, and many other assets. The first thing we want to do is determine which assets have strong signals for clustering users. We can use PCA, and a factor map to accomplish this goal:</p>
<p> </p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># filter on affluent households</span>
affluent &lt;-<span class="st"> </span>households[households<span class="op">$</span>netWorth <span class="op">&gt;=</span><span class="st"> </span><span class="dv">1000000</span>,]
<span class="kw">cat</span>(<span class="kw">paste</span>(<span class="st">&quot;Affluent: &quot;</span>, <span class="kw">floor</span>(<span class="kw">sum</span>(affluent<span class="op">$</span>weight))))

<span class="co"># plot a Factor Map of assets </span>
<span class="kw">fviz_pca_var</span>(<span class="kw">PCA</span>(affluent,  <span class="dt">graph =</span> <span class="ot">FALSE</span>), 
  <span class="dt">col.var=</span><span class="st">&quot;contrib&quot;</span>,    <span class="dt">gradient.cols =</span> <span class="kw">c</span>(<span class="st">&quot;#00AFBB&quot;</span>, 
  <span class="st">&quot;#E7B800&quot;</span>, <span class="st">&quot;#FC4E07&quot;</span>), <span class="dt">repel =</span> <span class="ot">TRUE</span>)<span class="op">+</span>
<span class="st">  </span><span class="kw">labs</span>(<span class="dt">title=</span><span class="st">&quot;Affluent Households - Assets Factor Map&quot;</span>)</code></pre></div>
<p>The results plotted above show that there are a few different asset groups that vary across affluent households. The most significant factor is business equity. Some other groupings of factors include investment assets (STOCKS, BONDS) and real estate assets/retirement funds.</p>
<div class="figure"><span id="fig:6-9"></span>
<img src="images/6-9.png" alt="A factor map showing differences in asset allocations." width="100%" />
<p class="caption">
Figure 6.9: A factor map showing differences in asset allocations.
</p>
</div>
<div id="how-many-clusters-to-use" class="section level3">
<h3><span class="header-section-number">6.3.1</span> How many clusters to use?</h3>
<p>We’ve now shown signs that there are different types of millionaires, and that assets vary based on net worth segments. To understand how asset allocation differs by net worth segment, we can use cluster analysis. We first identify clusters in the affluent survey respondents, and then apply these labels to the overall population of survey respondents.</p>
<p> </p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">k &lt;-<span class="st"> </span><span class="dv">7</span>
res.hc &lt;-<span class="st"> </span><span class="kw">eclust</span>(
  households[<span class="kw">sample</span>(<span class="kw">nrow</span>(households), <span class="dv">1000</span>), ],
  <span class="st">&quot;hclust&quot;</span>, <span class="dt">k =</span> k, <span class="dt">graph =</span> <span class="ot">FALSE</span>) 
<span class="kw">fviz_dend</span>(res.hc, <span class="dt">rect =</span> <span class="ot">TRUE</span>, <span class="dt">show_labels =</span> <span class="ot">FALSE</span>)</code></pre></div>
<p>To determine how many clusters to use, I created a cluster dendrogram using the code snippet above. The result is the figure shown above. I also varied the number of clusters, k, until we had the largest number of distinctly identifiable clusters.</p>
<div class="figure"><span id="fig:6-10"></span>
<img src="images/6-10.png" alt="A hierarchical visualization of the cluster assignments." width="100%" />
<p class="caption">
Figure 6.10: A hierarchical visualization of the cluster assignments.
</p>
</div>
<p>If you’d prefer to take a quantitative approach, you can use the fviz_nbclust function, which computes the optimal number of clusters using a silhouette metric. For our analysis, I decided on 7.</p>
<p> </p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">clarax &lt;-<span class="st"> </span><span class="kw">clara</span>(affluent, k)
<span class="kw">fviz_cluster</span>(clarax, <span class="dt">stand =</span> <span class="ot">FALSE</span>, 
             <span class="dt">geom =</span> <span class="st">&quot;point&quot;</span>, <span class="dt">ellipse =</span> F)</code></pre></div>
<p>To cluster the affluent households into unique groupings, I used the CLARA algorithm. A visualization of the different clusters is shown above. The results are similar to PCA and the factor map approach discussed earlier.</p>
<div class="figure"><span id="fig:6-11"></span>
<img src="images/6-11.png" alt="A visualization of the two-principal components identified by PCA." width="100%" />
<p class="caption">
Figure 6.11: A visualization of the two-principal components identified by PCA.
</p>
</div>
</div>
<div id="cluster-descriptions" class="section level3">
<h3><span class="header-section-number">6.3.2</span> Cluster Descriptions</h3>
<p>Now that we’ve determined how many clusters to use, it’s useful to inspect the clusters and assign qualitative labels based on the feature sets. The code snippet below shows how to compute the average feature values for the 7 different clusters.</p>
<p> </p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">groups &lt;-<span class="st"> </span>clarax<span class="op">$</span>clustering
results &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(
           <span class="kw">t</span>(<span class="kw">aggregate</span>(affluent,<span class="kw">list</span>(groups),mean)))
results[<span class="dv">2</span><span class="op">:</span><span class="dv">18</span>,]</code></pre></div>
<p>The results of this code block are shown below. Based on these results, we came up with the following cluster descriptions:</p>
<ul>
<li><strong>V1:</strong> Stocks/Bonds — 31% of assets, followed by home and mutual funds</li>
<li><strong>V2:</strong> Diversified — 53% busequity, 10% home and 9% in other real estate</li>
<li><strong>V3:</strong> Residential Real Estate — 48% of assets</li>
<li><strong>V4:</strong> Mutual Funds — 50% of assets</li>
<li><strong>V5:</strong> Retirement — 48% of assets</li>
<li><strong>V6:</strong> Business Equity — 85% of assets</li>
<li><strong>V7:</strong> Commercial Real Estate — 59% of assets</li>
</ul>
<p>With the exception of cluster V7, containing only 3% of the population, most of the clusters are relatively even in size. The second smallest cluster represents 12% of the population while the largest cluster represents 20%. You can use table(groups) to show the unweighted cluster population sizes.</p>
<div class="figure" style="text-align: center"><span id="fig:6-12"></span>
<img src="images/6-12.png" alt="Asset allocation amounts for the 7-identified clusters." width="80%" />
<p class="caption">
Figure 6.12: Asset allocation amounts for the 7-identified clusters.
</p>
</div>
</div>
<div id="cluster-populations-by-net-worth" class="section level3">
<h3><span class="header-section-number">6.3.3</span> Cluster Populations by Net Worth</h3>
<p>The last step in this analysis is to apply the different cluster assignments to the overall population, and to group the populations by net worth segments. Since we trained the clusters on only affluent households, we need to use a classification algorithm to label the non-affluent households in the population. The code snippet below uses knn to accomplish this task. The remaining code blocks compute the number of households that are classified as each cluster, for each of the net worth segments.</p>
<p> </p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># assign all of the households to a cluster </span>
groups &lt;-<span class="st"> </span><span class="kw">knn</span>(<span class="dt">train =</span> affluent, <span class="dt">test =</span> households, 
 <span class="dt">cl =</span> clarax<span class="op">$</span>clustering, <span class="dt">k =</span> k, <span class="dt">prob =</span> T, <span class="dt">use.all =</span> T)

<span class="co"># figure out how many households are in each cluster </span>
clusters &lt;-<span class="st"> </span><span class="kw">data.frame</span>(
  <span class="dt">c1 =</span> <span class="kw">ifelse</span>(groups <span class="op">==</span><span class="st"> </span><span class="dv">1</span>, weights, <span class="dv">0</span>), 
  ... 
  <span class="dt">c7 =</span> <span class="kw">ifelse</span>(groups <span class="op">==</span><span class="st"> </span><span class="dv">7</span>, weights, <span class="dv">0</span>) 
)

<span class="co"># assign each household to a net worth cluster </span>
nw &lt;-<span class="st"> </span><span class="kw">floor</span>(<span class="dv">2</span><span class="op">*</span><span class="kw">log10</span>(nwHouseholds))<span class="op">/</span><span class="dv">2</span>
results &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(<span class="kw">t</span>(<span class="kw">aggregate</span>(clusters,
                                  <span class="kw">list</span>(nw),sum)))

<span class="co"># compute the number of households for each segment</span>
results<span class="op">$</span>V1 &lt;-<span class="st"> </span>results<span class="op">$</span>V1<span class="op">/</span><span class="kw">sum</span>(<span class="kw">ifelse</span>(nw<span class="op">==</span><span class="dv">4</span>,weights,<span class="dv">0</span>))
...
results<span class="op">$</span>V11 &lt;-<span class="st"> </span>results<span class="op">$</span>V11<span class="op">/</span><span class="kw">sum</span>(<span class="kw">ifelse</span>(nw<span class="op">==</span><span class="dv">9</span>,weights,<span class="dv">0</span>))

<span class="co"># plot the results </span>
plot &lt;-<span class="st"> </span><span class="kw">plot_ly</span>(results, <span class="dt">x =</span> <span class="op">~</span><span class="dv">10</span><span class="op">^</span>Group.<span class="dv">1</span>, <span class="dt">y =</span> <span class="op">~</span><span class="dv">100</span><span class="op">*</span>c1, 
  <span class="dt">type=</span><span class="st">&#39;scatter&#39;</span>, <span class="dt">mode =</span> <span class="st">&#39;lines&#39;</span>, <span class="dt">name =</span> <span class="st">&quot;Stocks&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">add_trace</span>(<span class="dt">y =</span> <span class="op">~</span><span class="dv">100</span><span class="op">*</span>c2, <span class="dt">name =</span> <span class="st">&quot;Diversified&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">  </span>...
  <span class="kw">add_trace</span>(<span class="dt">y =</span> <span class="op">~</span><span class="dv">100</span><span class="op">*</span>c7, <span class="dt">name =</span> <span class="st">&quot;Commercial R.E.&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">layout</span>(<span class="dt">yaxis =</span> <span class="kw">list</span>(<span class="dt">title =</span> <span class="st">&#39;% of Households&#39;</span>),
     <span class="dt">xaxis=</span><span class="kw">list</span>(<span class="dt">title =</span> <span class="st">&quot;Net Worth ($)&quot;</span>, <span class="dt">type =</span> <span class="st">&quot;log&quot;</span>), 
     <span class="dt">title=</span><span class="st">&quot;Cluster Populations by Net Worth&quot;</span>)</code></pre></div>
<p>The results of this process are shown in the figure below. The chart shows some obvious and some novel results: home ownership and retirement funds make up the majority of assets for non-affluent households, there is a relatively even mix of clusters around $2M (excluding commercial real estate and business equity), and business equity dominates net worth for the ultra-wealthy households, followed by other investment assets.</p>
<div class="figure"><span id="fig:6-13"></span>
<img src="images/6-13.png" alt="How the distribution of clusters varies based on Household Net Worth." width="100%" />
<p class="caption">
Figure 6.13: How the distribution of clusters varies based on Household Net Worth.
</p>
</div>
<p>For this clustering example, I explored survey data and identified seven different types of affluent households. I then used these clusters to assign labels to the remaining households. A similar approach could be used at a startup to assign segmentation labels to the user base.</p>
</div>
</div>
<div id="conclusion-4" class="section level2">
<h2><span class="header-section-number">6.4</span> Conclusion</h2>
<p>Predictive modeling is an application of machine learning with a wide variety of tools that can be used to get started. One of the first things to consider when building a predictive model is determining the outcome that you’re trying to predict, and establishing metrics that you’ll use to measure success.</p>
<p>In this chapter, I showed four different approaches for building classification models for predicting twins during pregnancy. I showed how the GUI based tools Weka and BigML can be used to evaluate logistic regression models, ensemble models, and deep nets. I also provided scripting examples for performing logistic regression with regularization in R, and random forests in Python. I concluded the chapter with an example of clustering, which may by useful for performing segmentation tasks for a startup.</p>
<p>Independent of the approach being used to build a predictive model, it’s important to be able to output a model specification as a result of your training process. This can be a list of coefficient weights for a linear regression model, a list of nodes and weights for a random forest model, or a list of neuron weights and activations for a deep learning network. In the next chapter, I’ll discuss how to scale predictive models to millions of users, and being able to represent a trained model as a specification is a prerequisite to production.</p>

</div>
</div>
<div class="footnotes">
<hr />
<ol start="14">
<li id="fn14"><p><a href="https://www.cs.waikato.ac.nz/ml/weka/" class="uri">https://www.cs.waikato.ac.nz/ml/weka/</a><a href="predictive-modeling.html#fnref14">↩</a></p></li>
<li id="fn15"><p><a href="https://bigml.com/" class="uri">https://bigml.com/</a><a href="predictive-modeling.html#fnref15">↩</a></p></li>
<li id="fn16"><p><a href="https://www.federalreserve.gov/econres/scfindex.htm" class="uri">https://www.federalreserve.gov/econres/scfindex.htm</a><a href="predictive-modeling.html#fnref16">↩</a></p></li>
<li id="fn17"><p><a href="https://bit.ly/2kp5ANb" class="uri">https://bit.ly/2kp5ANb</a><a href="predictive-modeling.html#fnref17">↩</a></p></li>
<li id="fn18"><p><a href="https://bit.ly/2koWEHi" class="uri">https://bit.ly/2koWEHi</a><a href="predictive-modeling.html#fnref18">↩</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="exploratory-data-analysis.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="productizing-models.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/rstudio/bookdown-demo/edit/master/06-model.Rmd",
"text": "Edit"
},
"download": ["startup-data-science.pdf", "startup-data-science.epub"],
"toc": {
"collapse": "subsection"
}
});
});
</script>

</body>

</html>
